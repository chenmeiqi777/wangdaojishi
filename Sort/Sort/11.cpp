//
//  11.cpp
//  Sort
//
//  Created by chenmeiqi on 2019/2/25.
//  Copyright © 2019年 chenmeiqi. All rights reserved.
//

//我们容易联想到，要输出前 m 大的数，我们只需将其降序排序，然后输出前 m 个数即可。那么，读者可能不禁会产生疑问，这不就是排序么，而这个问题我 们在本章第一节中不是已经讨论过了，为什么这里又再次提出来了。如果读者有 这个疑问，你就要反问自己了:你是否忽略了什么?我们在前几例中并没有着重 分析算法的复杂度，但这不代表复杂度分析在我们解题的过程中不那么重要，相反复杂度分析是一个算法可行的前提与保证。即使本文没有明确的分析复杂度， 读者也要有自己估算复杂度的意识。在本例中，如果使用排序来解决该题，由于待排序数字的数量十分庞大(1000000)，即使使用时间复杂度为 O(nlogn) 的快速排序，其时间复杂度也会达到千万数量级，而这在一秒时限内是不能被我们所接受的，所以这里，我们并不能使用快速排序来解决本题。
//有了上例的启发，读者应该很快就能注意到，本例与上例有一个共同的特点: 输入数量的有限性。该例题面限定了输入的数字一定是[-500000,500000]区间里的整数，且各不相同。若利用一个数组分别统计每一种数字是否出现，其空间复杂度依旧在题目的限定范围内。且统计出现数字当中较大的 m 个数字，也仅需 从尾至头遍历这个数组，其时间复杂度仍在百万数量级，所以该解法是符合我们要求的。
#include <iostream>
int main(int argc, const char * argv[]) {
    using namespace std;
    int number[1000001]={0};
    int n,m,data=0;
    cin>>n>>m;
    while(n>0){
        cin>>data;
        data+=500000;
        number[data]=data-500000;
        n--;
    }
    for(int i=1000000;i>=0;i--){
        if(number[i]>0){
            if(m>1)cout << number[i]<<" ";              // 注意观察输出格式！在输出的每一个数字之间存在着一个空格，而在最后一个数字之后却不存在空格
            else if(m==1)cout << number[i];
            m--;
        }
    }
    return 0;
}
